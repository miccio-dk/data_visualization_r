\chapter{Design}
This chapter focuses on the design and implementation of the proposed solution into a viable product.
It will attempt to thoroughly describe the overall design of the system, as well as the implementation details of its building blocks.
Adequate considerations about the development process will be drawn in the conclusion section.

For the sake of convenience, the proposed system can be divided into two conceptual categories: the part that shall be deployed at the end users' premises (the apps running on mobile phones) and the one that shall be under direct control of the data analyst.
The latter further comprises a cloud-based infrastructure, and an R application, which can be executed on any host machine, or hosted on a server.


\section{Infrastructure}
The devised infrastructure relies on a cloud-based storage solution, provided by \emph{Google Sheets}.
This well-known platform can be easily accessed through its web interface, which mimics the appearance and functionalities of most modern spreadsheet software such as \emph{Microsoft Excel}, and through its extensive API (application programming interface), which allows third-party applications to read and update the content of a given spreadsheet.

The sensors data, consisting in GPS positioning information (as described in the Software Requirements Specifications), are collected collected by the tracking apps in the end users' mobile phones, and submitted to a specific spreadsheet document, which is otherwise private.
New data is continuously added to this file, with new entries being appended below existing ones.

The recorded data can then be accessed through a web application written in R.
The application periodically queries the document in order to update the information shown.
Is can be executed from the data analyst computer, or hosted on a cloud platform.

\fig{5cm}{nwd_network.png}{Overall system infrastructure: network diagram}{nwd_network}

The figure above expresses the relations between the aforementioned elements of the infrastructure.
The blue hexagons represents cloud-based services.
The dotted line suggests a possible hosting solution, based on \emph{ShinyApps.io}.

\section{iOS}



\section{Android}


\subsection{Project structure}
% structure
% build system
% important files

\subsection{Interface}
The UI of the app is composed of three graphical elements: a text input box for entering a custom time interval in seconds, and start and stop tracking buttons.
The widgets are arranged using a \code{LinearLayout}.
Other aspects of the user interface include \emph{toats}, which are small, temporary pop-up messages that appear at each submitted location.
The figure below shows a screen capture of the app, with one such message.

\fig{9cm}{ss_app.png}{Android App: user interface layout}{ss_app}

A previous version of the app --- not backed by the \code{Service} class --- featured a text box showing information about the latest location acquired.


\subsection{User Authentication}


\subsection{Location tracking}


\subsection{Data submission}



\section{R}
The R application is the part of the solution that is supposed to run on-premises.
It takes care of gathering the data from the spreadsheet document and generating a web interface with a map and chart for visualizing said data.
The software is built around the \emph{Shiny} framework, which provides functionalities for developing web applications in R.


\subsection{R \emph{Shiny} architecture}
The features that allows Shiny to provide responsive feedback lies in the update policy of certain code block and interface elements, which can be invalidated by other expressions or user interaction.
Expressions that are invalidated will be immediately reevaluated or redrawn.

% reactive plot http://shiny.rstudio.com/articles/reactivity-overview.html
\fig{9cm}{rd_shiny.png}{Shiny Application: reactivity diagram}{rd_shiny}

The picture above shows the relations between the different blocks of code.
If two elements are connected, whenever the origin changes changes, the destination is notified that it needs to re-execute.
The dotted line represents a periodic operation.
The system inputs, outputs, and reactive expressions are denoted by the cyan, green, and orange nodes respectively.
The red nodes represents observer and reactive events that are triggered by the invalidation of the affected elements.


\subsection{Interface}
The UI of the web application is written in R in a declarative paradigm.
Each graphic element is defined within its hierarchical parent, along with a set of options.
The R code returns a block of \code{html} elements that implement the UI.
Shiny uses the \code{bootstrap} front-end framework to allow for responsive pages, and comes with a series of built-in widgets for user interaction.

The page is based on the the \code{sidebarLayout}, which consists in a main area, used to visualize a map with the end users' positions and a plot of recorded speed and altitude, and a side bar, with filtering and data export options.

\fig{7cm}{ss_ui.png}{Shiny Application: user interface layout}{ss_ui}

The figure above shows an example session, with all the previously described controls.
The following UI widgets have been employed:

\begin{description}
	\item[\code{checkboxInput()}] check-box with optional default state
	\item[\code{dateRangeInput()}] dates range selector, with integrated calendar picker; maximum as well as default start and end dates can be set
	\item[\code{selectInput()}] combo-box with optional multiple selection support
	\item[\code{actionButton()}] common press-button
	\item[\code{downloadButton()}] download button
\end{description}

Each widgets takes an ID and a label as mandatory parameters.
Commonly used formatting tags such as \code{hr}, \code{p}, and \code{h} headings are also available through Shiny.


\subsection{Data collection}
The sensors data from the users' mobile phones is queried within a reactive expression, which invalidate itself every five seconds.
This triggers a continuous background update of the data, which is then propagated through all the reactive elements.

The data is accessed using the Google Sheet APIs and the \code{googlesheets} package: a file object is created from the document key, which is then used to read a range of columns.
The result is stored in a data-frame, where a new column is added, containing the date and time in POSIX format.


\subsection{Data filtering}
Once the row data have been collected, the Shiny back-end proceeds to reevaluate the filtering, which is based on the device IDs and date range chosen in the interface.
The resulting subset of entries is then sorted by device ID and time, in order to simplify its visualization.

These operations are performed usings the \code{dplyr} package, which provides useful tools for data manipulation.
In particular, the \code{filter()} and \code{arrange()} functions have been employed.


\subsection{Map visualization}
The map integration package \code{leaflef} allows the developer to include custom elements, including markers, polygons, and lines.
Though a simple data frame with latitude and longitude values in separate columns is enough to describe most geometrical entities, more complex data formats are available as inputs, provided by the package \code{sp}, which contains classes and methods for spatial data.

The \emph{Spatial Lines Data Frame} class has been used to plot several poly-lines and color them accordingly.
The data has been encapsulated into the correct format --- comprising a list of coordinates and an ID field --- using the R function \code{lapply()}, which performs a user-defined function on the elements of an array.
It this case, it has been performed on the list of unique device IDs, that have then been used to filter the relevant coordinates and generate \emph{Spatial Line} objects.

In order to avoid reloading the whole map at every update cycle, a reactive \emph{observer} is employed, where only the overlaying elements are redrawn.
These include the lines, markers, and legend, which follow a consistent color scheme.
The colors are picked by a reactive function with internally uses a discrete palette and performs interpolation when the number of devices to show differs from the number of available colors.
Further formatting options, including stroke width and opacity, is also applied.


\subsection{Plot visualization}
Although R comes with several valid built-in plotting libraries and methods, they output static images, which has deemed too limiting in terms of user interaction.
It has therefore been chosen to adopt \emph{Plotly}, an online data visualization framework written in JavaScript.
Whilst several similarly-aimed tools are availble, Plotly provides seamless integration with R and Shiny through its official package, and has recently been released as open source.

The chart featured in the final product has been generated using the following three functions:
\begin{description}
	\item[\code{plot\_ly()}] instantiate a new plot device, with optional dataset parameter
	\item[\code{add\_trace()}] adds a new set of data to the current plot. It is possible to select between various types of plots and visualizations; in this case, two scatter traces (altitude and speed) have been added and visualized as bars and lines respectively
	\item[\code{layout()}] sets up the plot canvas with title, axes names, labels, and grid
\end{description}
